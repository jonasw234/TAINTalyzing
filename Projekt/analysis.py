# -*- coding: utf-8 -*-
"""A module to analyze parse trees generated by the grammar."""
from __future__ import annotations
from copy import copy
import itertools
import logging
from os.path import basename
from typing import Any, Hashable

from modules.abstract_grammar import AbstractGrammar
from ruleset import Ruleset
from method import Method


def create_list_or_append_to_dict(dict_: dict, key: Hashable, value: Any):
    """Either create a new list at key `key` in `dict_` or append `value` directly to an existing
    list at `key`.

    Parameters
    ----------
    dict_ : dict
        The dict where to append the new item
    key : dict
        The key where to append `new_value`
    value : dict
        The value to append at `key`
    """
    try:
        if not value in dict_[key]:
            dict_[key].append(value)
    except KeyError:
        dict_[key] = [value]


class Analysis:
    """Analyzes a parse tree and saves the results."""
    logger = logging.getLogger('taintalyzing')

    def __init__(self, grammar: AbstractGrammar, ruleset: Ruleset):
        """Constructor for analysis object.

        Parameters
        ----------
        grammar : AbstractGrammar
            The grammar to use to analyze the input file
        ruleset : Ruleset
            The ruleset to analyze the input file with
        """
        self.grammar = grammar
        self.module = self.grammar.file_.module
        self.ruleset = ruleset
        self.ruleset.register_observer(self)
        self.methods = self.__find_methods()
        self.classes = self.grammar.get_class_definitions()
        self.globals_ = self.find_global_variables()

    def __find_methods(self) -> list:
        """Find all methods in the input file.

        Returns
        -------
        list
            List of all methods
        """
        methods = list()
        for method in self.grammar.get_method_definitions():
            methods.append(Method(method[1], method[2], method[0]['name'],
                                  self.grammar.get_parameters(method[1], method[2])))
        return methods

    def get_class_name_at(self, position: int) -> str:
        """Return the class name at position `position`.

        Parameters
        ----------
        position : int
            The position in the file

        Returns
        -------
        str
            The class name at this position
        """
        for class_name, start in reversed(self.classes.items()):
            if start > position:
                continue
            return class_name
        return None

    def unify_object_name(self, object_name: str, position: int) -> str:
        """Unifies an object name.
        Unified form: filename:object_name, where object_name has the first self reference
        replaced by the corresponding class name if applicable.

        Parameters
        ----------
        object_name : str
            Object name to be unified
        position : int
            A column in the object's name

        Returns
        -------
        str
            The unified object name
        """
        if object_name:
            self_identifier = self.grammar.get_self_identifier()
            if self_identifier:
                if object_name.index(self_identifier) == 0:
                    class_name = self.get_class_name_at(position)
                    object_name.replace(self_identifier, class_name, 1)
        object_name = ':'.join([basename(self.grammar.file_path), object_name])
        return object_name

    def update(self, method_: Method, changed_sanitizer: bool = False, new_source: bool = False):
        """Update list of sinks or sanitizers if necessary.

        If `changed_sanitizer` is False, only search for changed sinks, otherwise search for changed
        sanitizers too.

        If `new_source` is set, a new source was added to the list.

        Parameters
        ----------
        method_ : Method
            The method that was updated
        changed_sanitizer : bool, optional
            A sanitizer was changed
        new_source : bool, optional
            A new source was added
        """
        for method in self.methods:
            if method_.start == method.start:
                # No use in checking for new sinks if the method has added the possible
                # sink/sanitizer to itself
                continue
            if new_source:
                self.find_sources(method)
            else:
                self.find_sinks(method)
                if changed_sanitizer:
                    self.find_sanitizers(method)
            self.find_taints(method)

    def fix_object_names(self, method: Method):
        """Find variables that have an object name that is not in `self.classes` and try to find
        their original object name.

        Parameters
        ----------
        method : Method
            The method in which to fix object names
        """
        if self.classes:
            # Only necessary if there are any classes that could be used
            fixed_object_names = dict()  # variable: new object name
            for object_name, ident in copy(method.variables).keys():
                if object_name not in self.classes:
                    source_ = self.find_variable_source(method, object_name, ident,
                                                        method.variables[(object_name,
                                                                          ident)][0][1])
                    try:
                        real_object_name = source_[0][0]['expression'][0]['name']['ident'][0]
                    except KeyError:
                        real_object_name = source_[0][0][0]['object_name'][0]
                    if real_object_name != object_name:
                        fixed_object_names[ident] = real_object_name
                        # Add new entry to variables
                        method.variables[(real_object_name, ident)] = method.variables[(object_name,
                                                                                        ident)]
                        # Delete old entry
                        del method.variables[(object_name, ident)]
            # Update object name in calls
            for method_call in self.method_calls(method).values():
                object_name = method_call[0][0].get('object_name')
                if object_name:
                    old_object_name = object_name[0][0]
                    if old_object_name in fixed_object_names:
                        method_call[0][0]['object_name'][0][0] = fixed_object_names[old_object_name]

    def find_sources(self, method: Method) -> dict:
        """Find sources (inputs) in the input file.
        This will not check for variable inputs, so it produces a list of possible sources, which
        will always be a subset of the real list of sources, later to be filtered by
        `find_taints`.

        Parameters
        ----------
        method : Method
            The method to find sources in

        Returns
        -------
        dict
            Dictionary of source: call
        """
        sources = dict()
        for method_name, call in self.method_calls(method).items():
            for source_ in self.ruleset.sources:
                object_name = method_name.get('object_name', [None])[0]
                method_ident = method_name['ident'][0]
                if object_name and source_.object_name != object_name:
                    continue
                for source_method in source_.methods:
                    if source_method['Methodname'] != method_ident or \
                            len(source_method['Parameters']) != len(call[0].get('args', [])):
                        continue
                    create_list_or_append_to_dict(sources, source_, call)
        method.add_sources(sources)
        return sources

    def find_sinks(self, method: Method) -> dict:
        """Find sinks (uses) in the input file.
        This will not check for variable inputs, so it produces a list of possible sinks, which
        will always be a subset of the real list of sinks, later to be filtered by
        `find_taints`.

        Parameters
        ----------
        method : Method
            The method to find sinks in

        Returns
        -------
        dict
            Dictionary of sink: call
        """
        sinks = dict()
        for method_name, call in self.method_calls(method).items():
            for sink_ in self.ruleset.sinks:
                object_name = method_name.get('object_name', [[None]])[0][0]
                method_ident = method_name['ident'][0]
                if object_name and sink_.object_name != object_name:
                    continue
                for sink_method in sink_.methods:
                    if call[0][0].get('object_name') and \
                            object_name != sink_.object_name or \
                            sink_method['Methodname'] != method_ident or \
                            len(sink_method['Parameters']) != len(call[0].get('args', [])):
                        continue
                    create_list_or_append_to_dict(sinks, sink_, call)
        method.add_sinks(sinks)
        return sinks

    def __build_taint_parameter_list(self, method: Method, parameters: list, call: dict) -> (list,
                                                                                             bool):
        """Build a list of tainted parameters in `call`.

        That is, check which parameters in `call` that are tainted in the `parameters` list are
        based on the parameters from `method` and return them.

        Parameters
        ----------
        method : Method
            The method to analyze
        parameters : list
            The list of parameters that need to be checked
        call : dict
            The call to analyze

        Returns
        -------
        (bool, list)
            First value indicates whether all of the parameters are based on parameters from
            `method`, the second value indicates where they are.
        """
        all_parameters = True
        tainted_parameters = []
        for _ in method.parameters:
            for idx, arg_ in enumerate(parameters):
                if arg_ == '$TAINT':
                    if self.find_variable_source(
                            method,
                            self.get_class_name_at(call[1]),
                            call[0]['args'][idx],
                            call[1])[0][1] != 0:
                        all_parameters = False
                        break
                    else:
                        tainted_parameters.append('$TAINT')
            else:
                tainted_parameters.append(None)
        return all_parameters, tainted_parameters

    def find_sanitizers(self, method: Method) -> dict:
        """Find potential sanitizers (that clean sources before they are used in sinks) in the input
        file.  This will not check for variable inputs, so it produces a list of possible
        sanitizers, which will always be a subset of the real list of sanitizers, later to be
        filtered by `find_taints`.

        Parameters
        ----------
        method : Method
            The method to find sanitizers in

        Returns
        -------
        dict
            Dictionary of sanitizer: call
        """
        sanitizers = dict()
        for method_name, call in self.method_calls(method).items():
            for sink_ in self.ruleset.sinks:
                for sink_method_idx, sink_method in enumerate(sink_.methods):
                    for sanitizer_ in sink_method['Sanitizers']:
                        object_name = method_name.get('object_name', [[None]])[0][0]
                        method_ident = method_name['ident'][0]
                        if object_name and sanitizer_.object_name != object_name:
                            continue
                        for sanitizer_method in sanitizer_.methods:
                            if call[0][0].get('object_name') and \
                                    object_name != sanitizer_.object_name or \
                                    method_ident != sanitizer_method['Methodname']:
                                # Make sure sanitizer_method is called in the current method
                                break
                            if sanitizer_method['Methodname'] != method_ident or \
                                    len(sanitizer_method['Parameters']) != len(call[0].get('args',
                                                                                           [])):
                                continue
                            # We found a sanitizer in this method, so the method itself is a
                            # sanitizer for `sink_` if its parameters are part of the sanitizer
                            all_parameters, parameters = self.__build_taint_parameter_list(
                                method, sanitizer_method['Parameters'], call)
                            if all_parameters:
                                new_sanitizer = {
                                    self.get_class_name_at(method.start):
                                        {'Methods': [{'Methodname': method.method_name['ident'][0],
                                                      'Parameters': parameters,
                                                      'Comment':
                                                      f"Calls {sanitizer_method['Methodname']} "
                                                      f"from {sanitizer_.object_name}."}]}}
                                self.ruleset.add_sanitizer(method, sink_, sink_method_idx,
                                                           new_sanitizer, level=sanitizer_.level +
                                                           1)
                                Analysis.logger.debug('Added sanitizer method "%s".',
                                                      method.method_name['ident'][0])
                            create_list_or_append_to_dict(sanitizers, sanitizer_, call)
        method.add_sanitizers(sanitizers)
        return sanitizers

    def find_paths_through(self, method: Method) -> list:
        """Find all paths through `method`.

        Parameters
        ----------
        method : Method
            The method to analyze

        Returns
        -------
        list
            The list of all paths
        """
        mutually_exclusives = list(self.grammar.get_mutually_exclusive_positions(method.start,
                                                                                 method.end))
        exclusives = []
        in_betweens = []
        count = -1
        last_position = method.start
        for idx, mutually_exclusive in enumerate(mutually_exclusives):
            if last_position > mutually_exclusive[1] + method.start:
                continue
            # Start of a new mutually exclusive block
            count += 1
            in_betweens.append((last_position, mutually_exclusive[1] + method.start))
            exclusives.append([])
            exclusives[count].append((mutually_exclusive[1] + method.start,
                                      mutually_exclusive[2] + method.start))
            has_end = False
            if len(mutually_exclusives[idx:]) > 1:
                for to_come in mutually_exclusives[idx + 1:]:
                    if to_come[0].get('alternative-end'):
                        has_end = True
                    if not has_end and not to_come[0].get('alternative'):
                        # Reached next mutually exclusive block
                        break
                    exclusives[count].append((to_come[1] + method.start,
                                              to_come[2] + method.start))
            if not has_end:
                # Insert pseudo node
                exclusives[count].append((exclusives[count][-1][1],
                                          exclusives[count][-1][1]))
            last_position = exclusives[count][-1][1]

        # Find all combinations between `exclusives` blocks for all possible paths
        paths = list(itertools.product(*exclusives))

        Analysis.logger.debug('Found %d mutually exclusive paths through "%s".', len(paths),
                              method.method_name)

        # Special case if there are not mutually exclusive paths
        if not paths[0]:
            paths[0] = [(method.start, method.end)]

        # Find the last position where a mutually exclusive block ends
        maximum = method.start
        for path in paths:
            tmp = path[-1][1]
            if tmp > maximum:
                maximum = tmp

        # Add missing steps
        for idx, _ in enumerate(paths):
            paths[idx] = list(paths[idx])
            # Insert connection from last exclusive block to method end
            paths[idx].append((maximum, method.end))
            # Append areas in between mutually exclusive blocks
            paths[idx].extend(in_betweens)
            paths[idx].sort()

        # Print each exclusive path in debug mode
        if Analysis.logger.getEffectiveLevel() == logging.DEBUG:
            for path in paths:
                Analysis.logger.debug('---START PATH---')
                Analysis.logger.debug('')
                for slice_ in path:
                    Analysis.logger.debug(self.grammar.file_contents[slice_[0]:slice_[1]])
                Analysis.logger.debug('')
                Analysis.logger.debug('---END PATH---')

        method.paths = paths
        return paths

    def __correct_positions(self, call: dict, use: dict, parameters: list) -> bool:
        """Identifies whether all parameters in the call that need to be tainted really are.

        Parameters
        ----------
        call : dict
            The call to analyze
        use : dict
            The variable use
        parameters : list
            List of tainted parameters

        Returns
        -------
        bool
            Whether all parameters are tainted
        """
        correct_positions = True
        for idx in range(len(call[0].get('args', []))):
            try:
                arg_ident = use[0]['args'][idx][0].get('ident')
            except AttributeError:
                arg_ident = use[0]['args'][idx].get('ident')
            if parameters[idx] == '$TAINT' and \
                    not arg_ident:
                correct_positions = False
                break
        return correct_positions

    def __in_path(self, method: Method, statement: tuple, path: list) -> bool:
        """Let me know if `statement` is part of `path`.

        Parameters
        ----------
        method : Method
            The method of the statement
        statement : tuple
            The statement to analyze
        path : list[]
            The list of slices in this path

        Returns
        -------
        bool
            True if `statement` is a part of `path`.
        """
        if statement[1] == 0:
            # Special case: Parameters are always part of the path
            return True
        for slice_ in path:
            if statement[1] + method.start >= slice_[0] and statement[1] + method.start < slice_[1]:
                return True
        return False

    def __check_sanitizer_subcall(self, sink_method: dict, arg: dict) -> dict:
        """Check for sanitizer in a subcall.

        Parameters
        ----------
        sink_method : dict
            The sink method the sanitizer should belong to
        arg : dict
            Check this argument of the sink method

        Returns
        -------
        dict
            The matching sanitizer
        """
        for sanitizer_ in sink_method['Sanitizers']:
            if sanitizer_.object_name != arg[0].get('object_name'):
                continue
            for sanitizer_method in sanitizer_.methods:
                sanitizer_parameters = sanitizer_method['Parameters']
                subcall_parameters = arg.get('args', [])
                if len(sanitizer_parameters) != len(subcall_parameters):
                    continue
                # Potential sanitizer method in subcall
                Analysis.logger.debug('The subcall seems to be to a sanitizer.')
                return sanitizer_

    def __check_source_subcall(self, source_: dict, arg: dict) -> bool:
        """Check for source subcalls.

        Parameters
        ----------
        source_ : dict
            Check for all methods for this source
        arg : dict
            Check this argument for the subcall

        Returns
        -------
        bool
            Whether the subcall is to a source
        """
        for source_method in source_.methods:
            source_parameters = source_method['Parameters']
            subcall_parameters = arg.get('args', [])
            if source_method['Methodname'] == arg[0]['ident'][0] and \
                    len(source_parameters) == len(subcall_parameters):
                Analysis.logger.debug('The subcall seems to be to a source method.')
                return True
        return False

    def __relevant_subcalls(self, sink: dict, call: dict) -> (bool, dict, str):
        """Checks for sources and sanitizers that are used in subcalls to `sink`.

        Parameters
        ----------
        sink : dict
            The sink the call belongs to
        call : dict
            The main call that will be analyzed

        Returns
        -------
        (bool, dict, str)
            Is there a source, the sanitizer if available and the comment for the sink method
        """
        has_source, sanitizer_is = False, None
        sink_method = None
        for sink_method in sink.methods:
            if sink.object_name == call[0][0].get('object_name') and \
                    sink_method['Methodname'] == call[0][0]['ident'][0]:
                # Possible sink method
                for idx, param in enumerate(sink_method['Parameters']):
                    subcall = call[0]['args'][idx]
                    if param != '$TAINT' or \
                            not subcall.get('name'):
                        continue
                    # Interesting parameter of sink method
                    args_ = [call[0]['args'][idx]]
                    all_arguments_checked = False
                    sanitizer_method = None
                    arg_is_sanitized = False
                    while True:
                        # Check for sources first
                        for arg_idx, arg in enumerate(args_, 1):
                            # Make sure that sanitizers also have user controlled inputs
                            if sanitizer_method:
                                if arg_idx == len(args_):
                                    sanitizer_method = None
                                elif sanitizer_method['Parameters'][arg_idx] == '$TAINT':
                                    arg_is_sanitized = True
                                else:
                                    arg_is_sanitized = False
                            if isinstance(arg[0], str):
                                if arg_idx == len(args_):
                                    all_arguments_checked = True
                                    break
                                continue
                            Analysis.logger.debug('Found subcall to "%s".', arg[0]['ident'][0])
                            for source_ in self.ruleset.sources:
                                if source_.object_name == arg[0].get('object_name'):
                                    has_source = self.__check_source_subcall(source_, arg)
                                    # Potential source method in subcall
                                    # No need to check for user controlled input here, because
                                    # sources that don't return anything would be useless in
                                    # subcalls, so we can assume they were at least *intended* to
                                    # return user input
                                    if has_source:
                                        if not arg_is_sanitized:
                                            sanitizer_is = None
                                        return (has_source, sanitizer_is, sink_method['Comment'])
                            # If it is not a source, it could still be a sanitizer
                            if not sanitizer_is:
                                # We only need one sanitizer because it has to match the sink
                                sanitizer_is = self.__check_sanitizer_subcall(sink_method, arg)
                            # Check for sub-subcalls
                            if not arg.get('name'):
                                break
                            args_ = arg.get('args')
                            subcall = arg
                        if all_arguments_checked:
                            break

        return (has_source, sanitizer_is, sink_method['Comment'])

    def __find_matching_source(self, source_: dict, call: dict, use: dict,
                               user_controlled_variables: dict, real_sources: dict):
        """Find matching source method for `call`.

        Parameters
        ----------
        source_ : dict
            The source whose methods to check
        call : dict
            The call to compare the source method to
        use : dict
            Where the source is used
        user_controlled_variables : dict
            Known user controlled variables
        real_sources : dict
            Known real sources, used to store the results
        """
        # Possible source corresponds with variable use
        for source_method in source_.methods:
            if source_method['Methodname'] != call[0]['name']['ident'][0]:
                # Source method doesn't match call
                continue
            if self.__correct_positions(call, use, source_method['Parameters']):
                # All positions have to match, so we need a second loop here
                if call[0].get('args'):
                    for idx in range(len(call[0].get('args', []))):
                        if source_method['Parameters'][idx] == '$TAINT':
                            user_controlled_variable = call[0]['args'][idx]
                            create_list_or_append_to_dict(
                                user_controlled_variables,
                                user_controlled_variable,
                                {'Position': (use[1], use[2])})
                else:
                    try:
                        if use[0].get('expression') and \
                                use[0]['expression'][0][0]['ident'][0] == \
                                call[0][0]['ident'][0]:
                            create_list_or_append_to_dict(
                                user_controlled_variables,
                                use[0][0],
                                {'Position': (use[1], use[2])})
                    except KeyError:
                        continue
                create_list_or_append_to_dict(real_sources, source_, call)

    def __verify_sources(self, method: Method, path: list, user_controlled_variables: dict) -> dict:
        """Verify sources and identify them as user controlled variables.

        Parameters
        ----------
        method : Method
            The method to analyze sources in
        path : list
            The path through the method
        user_controlled_variables : dict
            Dictionary of user controlled variables

        Returns
        -------
        dict
            A dict of verified real sources
        """
        real_sources = dict()
        for source_, calls in method.sources.items():
            for uses in method.variables.values():
                for call in calls:
                    for use in uses:
                        if not self.__in_path(method, use, path):
                            continue
                        if use[1] == call[1] and use[2] == call[2] or \
                                not call[0].get('args'):
                            self.__find_matching_source(source_, call, use,
                                                        user_controlled_variables, real_sources)
        return real_sources

    def __find_user_controlled_returns(self, method: Method, user_controlled_variables: dict,
                                       real_sources: dict):
        """Add sources that don't use variables, but return the user controlled input in
        assignments.

        Add the lvalues of these assignments to the `user_controlled_variables`, and the source to
        `real_sources`.

        Parameters
        ----------
        method : Method
            The method where to find the user controlled returns
        user_controlled_variables : dict
            Already known user controlled variables
        real_sources : dict
            Already known real sources
        """
        for source_, source_methods in method.sources.items():
            for call in source_methods:
                variable_use = False
                variable = None
                for variable in method.variables.values():
                    for use in variable:
                        if call[1] == use[1]:
                            variable_use = True
                            break
                    if variable_use:
                        break
                else:
                    # Didn't break above, source method is not using a variable as input (maybe
                    # returns it?)
                    create_list_or_append_to_dict(real_sources, source_, call)
                    absolute_start = call[1] + method.start
                    absolute_end = call[2] + method.start
                    line = self.grammar.file_.column_to_line(absolute_start)
                    line_start = self.grammar.file_.line_to_column(line)
                    line_end = self.grammar.file_.line_to_column(line + 1) - 1
                    for assignment in self.grammar.get_assignments(line_start, line_end):
                        if assignment[1] + line_start <= absolute_start and \
                                assignment[2] + line_end >= absolute_end:
                            # Found an assignment that matches with this source, the lvalue of the
                            # assignment is user controlled
                            create_list_or_append_to_dict(
                                user_controlled_variables,
                                assignment[0][0],
                                {'Position': (assignment[1] + line_start,
                                              assignment[2] + line_start)})

    def __find_user_controlled_assignments(self, method: Method, path: list,
                                           user_controlled_variables: dict) -> dict:
        """Find user controlled assignments.

        Parameters
        ----------
        method : Method
            The method to analyze
        path : list
            The current path
        user_controlled_variables : dict
            Dictionary of known user controlled variables

        Returns
        -------
        dict
            A dictionary of all user controlled assignments
        """
        user_controlled_assignments = dict()
        for uses in method.variables.values():
            for use in uses:
                if not self.__in_path(method, use, path):
                    continue
                if not use[0] or not use[0].get('lvalue'):
                    # Not an assignment
                    continue
                for user_controlled_variable, data in user_controlled_variables.items():
                    if use[1] < data[0]['Position'][0]:  # First source is always at first position
                        # This use is before the variable is user controlled
                        break
                    for operand in use[0]['expression']:
                        try:
                            ident = operand['name']['ident'][0]
                            object_name = operand['name'].get('object_name', [[None]])[0][0]
                        except KeyError:
                            ident = operand[0]
                            object_name = None
                        if ident == user_controlled_variable['ident'][0] and \
                                object_name == user_controlled_variable.get('object_name',
                                                                            [[None]])[0][0]:
                            create_list_or_append_to_dict(
                                user_controlled_assignments,
                                use[0]['lvalue'],
                                {'Position': (use[1], use[2]), 'Call': use[0]})
        return user_controlled_assignments

    def __add_sources_from(self, method: Method):
        """Add sources from a method if they are based on the method's parameters.

        Parameters
        ----------
        method : Method
            The method to add sources from
        """
        for source_, call in copy(method.sources).items():
            for source_method in source_.methods:
                if call[0][0][0]['ident'][0] == source_method['Methodname']:
                    # Found the matching method, check if correct parameters are user controlled
                    # All parameters need to be user controlled
                    all_parameter_based = True
                    indices = []
                    for param in source_method['Parameters']:
                        if not param == '$TAINT':
                            # Uninteresting parameter
                            continue
                        for arg in call[0][0]['args']:
                            if not arg.get('ident'):
                                # Not a variable
                                continue
                            trail = self.find_variable_source(method, arg.get('object_name'),
                                                              arg['ident'][0], call[0][1])
                            if trail:
                                if trail[0][1] != 0:
                                    all_parameter_based = False
                                    break
                                else:
                                    for idx, parameter in enumerate(method.parameters):
                                        if trail[0][0]['ident'][0] == parameter['ident'][0]:
                                            indices.append(idx)
                        if not all_parameter_based:
                            break
                    else:
                        # Didn't break above, all arguments are parameter based
                        parameters = []
                        for idx, _ in enumerate(method.parameters):
                            if idx in indices:
                                parameters.append('$TAINT')
                            else:
                                parameters.append(None)
                        new_source = {self.get_class_name_at(method.start):
                                      {'Methods': [{'Methodname':
                                                    method.method_name['ident'][0],
                                                    'Parameters': parameters,
                                                    'Comment':
                                                    f"Calls {source_method['Methodname']} from "
                                                    f"{source_.object_name}.",
                                                    'Sanitizers': []}]}}
                        self.ruleset.add_source(method, new_source)
                        Analysis.logger.debug('Added source method "%s".',
                                              method.method_name['ident'][0])

    def __find_matching_sink_method(self, method: Method, sink: dict, call: dict, use: dict,
                                    user_controlled_variables: dict, taints: dict, real_sinks:
                                    dict):
        """Find matching sink method for `call`.

        Parameters
        ----------
        method : Method
            The method where the sink is called
        sink : dict
            Check all methods for this sink
        call : dict
            The call to analyze
        use : dict
            Where the sink is used
        user_controlled_variables : dict
            Known user controlled variables
        taints : dict
            Known taints, extended in this method
        real_sinks : dict
            Known real sinks, extended in this method
        """
        for sink_method in sink.methods:
            if sink_method['Methodname'] != call[0]['name']['ident'][0]:
                # Sink method doesn't match call
                continue
            if self.__correct_positions(call, use, sink_method['Parameters']):
                # All positions have to match, so we need a second loop here
                for idx in range(len(use[0]['args'])):
                    if sink_method['Parameters'][idx] == '$TAINT':
                        for user_controlled_variable in \
                                user_controlled_variables.keys():
                            try:
                                object_name = use[0]['args'][idx].get(
                                    'object_name', [[None]])[0][0]
                                ident = use[0]['args'][idx]['ident'][0]
                            except KeyError:
                                object_name = use[0]['args'][idx][0].get(
                                    'object_name', [[None]])[0][0]
                                ident = use[0]['args'][idx][0]['ident'][0]
                            if object_name == \
                                user_controlled_variable.get('object_name',
                                                             [[None]])[0][0] \
                                    and ident == \
                                    user_controlled_variable['ident'][0]:
                                # Check if the sink is sanitized
                                sanitizer = self.__get_sanitizer(
                                    method, use, sink_method['Sanitizers'])
                                taint = {'Position': (use[1] + method.start,
                                                      use[2] + method.start),
                                         'Call': use[0],
                                         'Sanitizer': sanitizer,
                                         'Comment': sink_method['Comment']}
                                create_list_or_append_to_dict(taints, sink, taint)
                # It is possible that the rules for the user defined input are
                # missing, so this is still marked
                create_list_or_append_to_dict(real_sinks, sink, call)
                real_sinks[sink].append(sink_method['Comment'])

    def __verify_sinks(self, method: Method, path: list,
                       user_controlled_variables: dict, taints: dict) -> dict:
        """Verify sinks and add them to `taints` if their input is user controlled.

        Parameters
        ----------
        method : Method
            The method to analyze
        path : list
            The path through the method
        user_controlled_variables : dict
            Known user controlled variables
        taints : dict
            Output variable to store the taints

        Returns
        -------
        dict
            The verified sinks
        """
        real_sinks = dict()
        for sink, calls in method.sinks.items():
            for uses in method.variables.values():
                for call in calls:
                    for use in uses:
                        if not self.__in_path(method, use, path):
                            continue
                        if use[1] == call[1] and use[2] == call[2]:
                            # Possible sink corresponds with variable use
                            self.__find_matching_sink_method(method, sink, call, use,
                                                             user_controlled_variables, taints,
                                                             real_sinks)
        return real_sinks

    def __check_subcalls(self, method: Method, path: list) -> dict:
        """Check subcalls in `method` for sources that make the call a taint, also checking for
        sanitizers.

        Parameters
        ----------
        method : Method
            The method to analyze
        path : list
            The path to take

        Returns
        -------
        dict
            All known taints from subcalls
        """
        taints = dict()
        for sink, calls in method.sinks.items():
            for call in calls:
                if isinstance(call, str):  # Comments are appended after the calls
                    continue
                if not self.__in_path(method, call, path):
                    continue
                has_source, sanitizer, comment = self.__relevant_subcalls(sink, call)
                if has_source:
                    taint = {'Position': (call[1] + method.start,
                                          call[2] + method.start),
                             'Call': call[0],
                             'Sanitizer': sanitizer,
                             'Comment': comment}
                    create_list_or_append_to_dict(taints, sink, taint)
        return taints

    def __add_sinks_from(self, method: Method, taints: dict):
        """Add sinks from `method` to the ruleset if their inputs are based on the method's
        parameters.

        Parameters
        ----------
        method : Method
            The method to add the sinks from
        taints : dict
            List of all known taints
        """
        # Only add the method as a sink if the parameters of the sink are influenced by the
        # parameters of the method itself.
        for sink, data in taints.items():
            for entry in data:
                param_based = False
                parameter_list = list()
                if not entry['Call'].get('args'):
                    param_based = True
                    for param in method.parameters:
                        parameter_list.append(None)
                else:
                    # We could either check if only one of the $TAINT parameters is in the method
                    # arguments or we could check if all of them are.  This is a design decision and
                    # we opt for checking all parameters and having to create additional rules if it
                    # doesn't matter which one of the parameters is tainted, so that each rule has a
                    # set of parameters that *all* need to be tainted for it to be insecure.
                    args_ = entry['Call']['args']
                    if len(method.parameters) >= len(args_):
                        for param in method.parameters:
                            # Fill with default values, overwrite with $TAINT later
                            parameter_list.append(None)
                        for arg_ in args_:
                            try:
                                object_name = arg_.get('object_name')
                                ident = arg_['ident'][0]
                            except KeyError:
                                try:
                                    object_name = arg_[0].get('object_name')
                                    ident = arg_[0]['ident'][0]
                                except AttributeError:
                                    continue
                            trail = self.find_variable_source(method, object_name,
                                                              ident, entry['Position'][0])
                            if trail and trail[0][1] != 0:
                                break
                            # Search for arg_ position in parameter list and replace the position in
                            # parameter_list with $TAINT
                            for idx, param in enumerate(method.parameters):
                                if not trail or trail[0][0]['ident'][0] == param['ident'][0]:
                                    parameter_list[idx] = '$TAINT'
                        else:
                            # Didn't break above, all arguments are based on parameters
                            param_based = True
                if param_based:
                    class_name = self.get_class_name_at(method.start)
                    methods = [{'Methodname': method.method_name['ident'][0],
                                              'Parameters': parameter_list,
                                              'Comment':
                                              f"Calls {entry['Call'][0]['ident'][0]} from "
                                              f"{sink.object_name}.",
                                              'Sanitizers': []}]
                    for sink in self.ruleset.sinks:
                        if sink.object_name == class_name and \
                                sink.methods == methods:
                            break
                    else:
                        # Didn't break above, new sink
                        new_sink = {class_name:
                                    {'Methods': methods}}
                        self.ruleset.add_sink(method, new_sink)
                        Analysis.logger.debug('Added sink method "%s".',
                                              method.method_name['ident'][0])

    def find_taints(self, method: Method, path: list = None) -> dict:
        """Find taints (flows of sources to sinks that are not sanitized) in the input file.

        Parameters
        ----------
        method : Method
            The method to find taints in
        path : list, optional
            The path through the method.  Search the whole method if missing.

        Returns
        -------
        dict
            A dictionary of taints in the form of sink: {Position}
        """
        if not path:
            path = [(method.start, method.end)]

        # Parameters are potentially user controlled variables
        user_controlled_variables = dict()
        for param in method.parameters.keys():
            user_controlled_variables[param] = [{'Position': (0, 0)}]

        # Treat global variables like parameters
        for global_ in self.globals_:
            user_controlled_variables[global_[0]] = [{'Position': (0, 0)}]

        # Verify sources and identify them as user controlled variables
        real_sources = self.__verify_sources(method, path, user_controlled_variables)

        self.__find_user_controlled_returns(method, user_controlled_variables, real_sources)
        method.sources = real_sources

        # Enrich user controlled variables with new assignments of those user controlled variables
        # to other variables
        user_controlled_variables.update(self.__find_user_controlled_assignments(
            method, path, user_controlled_variables))

        # Add new sources if their input is based on the method's parameters
        self.__add_sources_from(method)

        # Try to find subcalls in sinks that have sources or sanitizers in them
        taints = self.__check_subcalls(method, path)

        # Verify sinks and check for possible taints
        method.sinks = self.__verify_sinks(method, path, user_controlled_variables, taints)

        # Add this method to list of sinks because it calls a sink with a user controlled input
        self.__add_sinks_from(method, taints)

        # Add new taints to the method
        method.add_taints(taints)
        return taints

    def __get_sanitizer(self, method: Method, possible_sink: dict, sanitizers_for_sink: list) -> \
            dict:
        """Return the sanitizer for a possible sink if it exists.

        Parameters
        ----------
        method : Method
            The method in which the sink occurs
        possible_sink : dict
            Dictionary of the possible sink
        sanitizers_for_sink : list
            A list of sanitizers for this sink

        Returns
        -------
        dict
            The sanitizer call if it exists, else `None`
        """
        for implemented_sanitizer, sanitizer_calls in method.sanitizers.items():
            for possible_sanitizer in sanitizers_for_sink:
                for sanitizer_call in sanitizer_calls:
                    if implemented_sanitizer is possible_sanitizer and \
                            sanitizer_call[1] <= possible_sink[1]:
                        return possible_sanitizer
        return None

    def find_variable_source(self, method: Method, object_name: str, variable: str, start:
                             int) -> list:
        """Return a list that leads from the source to the position where `variable` was used.

        Parameters
        ----------
        method : Method
            The method in which the variable is used
        object_name : str
            The name of the object the variable belongs to
        variable : str
            The name of the variable
        start : int
            Start position where the variable is used, only search before it

        Returns
        -------
        list
            A list leading from the source to the position where the variable was used
        """
        trail = []
        for identifier, uses in method.variables.items():
            if identifier[0] == object_name and identifier[1] == variable:
                # Trail the variable itself for earlier uses
                for use in uses:
                    if use[1] <= start:
                        trail.append(use)
        # Delete everything before the last assignment
        if len(trail) > 1:
            last_assignment_reached = False
            for breadcrumb in trail:
                if not last_assignment_reached:
                    if breadcrumb[0].get('lvalue'):
                        last_assignment_reached = True
                        continue
                else:
                    del breadcrumb
            # Find variables in assignments and add them to the list to follow
            if trail[0][0].get('lvalue'):
                expression = trail[0][0]['expression'][0]
                object_names = expression.get('object_name')
                idents = expression.get('ident', [])
                extended_trail = None
                for idx, _ in enumerate(idents):
                    object_name = None
                    if object_names and len(object_names) >= idx:
                        object_name = object_names[idx]
                    ident = idents[idx]
                    extended_trail = self.find_variable_source(method, object_name, ident,
                                                               trail[0][1])
                if extended_trail:
                    trail.extend(extended_trail)
        # Since method.variables is not an OrderedDict, we need to sort manually here
        trail.sort(key=lambda variable: variable[1])
        return trail

    def calculate_complexity(self, method: Method) -> int:
        """Calculate the cyclomatic complexity of a function.

        Parameters
        ----------
        method : Method
            The method to analyze

        Returns
        -------
        int
            The complexity of the function
        """
        complexity = self.grammar.get_edge_count(method.start, method.end) - \
            self.grammar.get_statement_count(method.start, method.end) + 2
        method.complexity = complexity
        return complexity

    def method_calls(self, method: Method) -> dict:
        """Returns a list of all methods that are called in `method`.

        Parameters
        ----------
        method : Method
            The method to inspect

        Returns
        -------
        dict
            Method name: call
        """
        if not method.calls:
            method_calls = dict()
            for method_call in self.grammar.get_method_calls(method.start, method.end):
                method_calls[method_call[0]['name']] = method_call
            method.calls = method_calls
        return method.calls

    def find_global_variables(self) -> list:
        """Find all global variables in the input file.

        Returns
        -------
        list
            A list of all the global variables
        """
        globals_ = self.grammar.get_global_variables()
        return globals_ if globals_ else []

    def follow_variables(self, method: Method) -> dict:
        """Follow variable assignments and their usage in calls.

        Parameters
        ----------
        method : Method
            The method to follow variables in

        Returns
        -------
        dict
            A dictionary of all the variables and a list of their assignments/uses in calls
        """
        # Start with parameters
        parameters = self.grammar.get_parameters(method.start, method.end)
        # Handling parameters as assignments makes it easier later
        variables = {(None, key['ident'][0]): [[{
            'ident': [key['ident'][0]],
            'lvalue': [key['ident'][0]],
            'expression':
                [{'name': {'ident': [value]}}]}, 0, 0]] for key, value in parameters.items()}
        Analysis.logger.debug('Found the following parameters: %s.', variables)

        # Add global variables as if they were part of the method itself
        for variable in self.globals_:
            create_list_or_append_to_dict(variables,
                                          (None,  # Global variables are not bound to an object
                                           variable[0]['ident'][0]),
                                          [{'ident': [variable[0]['ident'][0]],
                                             'lvalue': [variable[0]['ident'][0]],
                                             'expression':
                                                 [{'name': {'ident': [None]}}]}, 0, 0])

        # Get all declarations of variables
        declarations = self.grammar.get_declarations(method.start, method.end)
        for variable in declarations:
            create_list_or_append_to_dict(variables, (None, variable[0]['ident'][0]), variable)
        Analysis.logger.debug('Found the following parameters and declarations: %s.', variables)

        # Get all assignments to variables
        assignments = self.grammar.get_assignments(method.start, method.end)
        for variable in assignments:
            create_list_or_append_to_dict(variables,
                                          (variable[0]['lvalue'].get('object_name'),
                                           variable[0]['lvalue']['ident'][0]),
                                          variable)
        Analysis.logger.debug('Found the following parameters, declarations and assignments: %s.',
                              variables)

        # Get uses for variables
        # Generators cannot be reset, so convert it to a list for multiple iterations
        returns = list(self.grammar.get_returns(method.start, method.end))

        # Build dataflow graph
        for variable in variables:
            # Find out where those variables are used as parameters or objects
            for call in self.method_calls(method).values():
                if call[0][0].get('object_name', [[None]])[0][0] == variable[1]:
                    Analysis.logger.debug('Found the following use of variable "%s" as an '
                                          'object for a call: %s', variable, call)
                    variables[variable].append(call)
                else:
                    for arg in call[0].get('args', []):
                        if variable[1] == arg[0] or \
                                not isinstance(arg[0], str) and \
                                variable[1] == arg[0].get('ident', [None])[0]:
                            Analysis.logger.debug('Found the following use of variable "%s" in a '
                                                  'call: %s.', variable, call)
                            variables[variable].append(call)

            # Find out where those variables are used as return values
            for return_ in returns:
                if variable[1] in return_[0]['return_value']:
                    Analysis.logger.debug('Found the following use of a variable "%s" as a '
                                          'return value: %s.', variable, return_)
                    variables[variable].append(return_)

            # Sort the resulting lists by position in the code
            variables[variable].sort(key=lambda variable: variable[1])

        method.add_variables(variables)
        return variables
